// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements _Initial {
  const _$InitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements HomeState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$SignoutLoadingImplCopyWith<$Res> {
  factory _$$SignoutLoadingImplCopyWith(_$SignoutLoadingImpl value,
          $Res Function(_$SignoutLoadingImpl) then) =
      __$$SignoutLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignoutLoadingImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SignoutLoadingImpl>
    implements _$$SignoutLoadingImplCopyWith<$Res> {
  __$$SignoutLoadingImplCopyWithImpl(
      _$SignoutLoadingImpl _value, $Res Function(_$SignoutLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SignoutLoadingImpl
    with DiagnosticableTreeMixin
    implements SignoutLoading {
  const _$SignoutLoadingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.signoutLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.signoutLoading'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SignoutLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return signoutLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return signoutLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutLoading != null) {
      return signoutLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return signoutLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return signoutLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutLoading != null) {
      return signoutLoading(this);
    }
    return orElse();
  }
}

abstract class SignoutLoading implements HomeState {
  const factory SignoutLoading() = _$SignoutLoadingImpl;
}

/// @nodoc
abstract class _$$SignoutSuccessImplCopyWith<$Res> {
  factory _$$SignoutSuccessImplCopyWith(_$SignoutSuccessImpl value,
          $Res Function(_$SignoutSuccessImpl) then) =
      __$$SignoutSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignoutSuccessImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SignoutSuccessImpl>
    implements _$$SignoutSuccessImplCopyWith<$Res> {
  __$$SignoutSuccessImplCopyWithImpl(
      _$SignoutSuccessImpl _value, $Res Function(_$SignoutSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SignoutSuccessImpl
    with DiagnosticableTreeMixin
    implements SignoutSuccess {
  const _$SignoutSuccessImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.signoutSuccess()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.signoutSuccess'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SignoutSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return signoutSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return signoutSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutSuccess != null) {
      return signoutSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return signoutSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return signoutSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutSuccess != null) {
      return signoutSuccess(this);
    }
    return orElse();
  }
}

abstract class SignoutSuccess implements HomeState {
  const factory SignoutSuccess() = _$SignoutSuccessImpl;
}

/// @nodoc
abstract class _$$SignoutErrorImplCopyWith<$Res> {
  factory _$$SignoutErrorImplCopyWith(
          _$SignoutErrorImpl value, $Res Function(_$SignoutErrorImpl) then) =
      __$$SignoutErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignoutErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SignoutErrorImpl>
    implements _$$SignoutErrorImplCopyWith<$Res> {
  __$$SignoutErrorImplCopyWithImpl(
      _$SignoutErrorImpl _value, $Res Function(_$SignoutErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SignoutErrorImpl with DiagnosticableTreeMixin implements SignoutError {
  const _$SignoutErrorImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.signoutError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.signoutError'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SignoutErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return signoutError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return signoutError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutError != null) {
      return signoutError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return signoutError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return signoutError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (signoutError != null) {
      return signoutError(this);
    }
    return orElse();
  }
}

abstract class SignoutError implements HomeState {
  const factory SignoutError() = _$SignoutErrorImpl;
}

/// @nodoc
abstract class _$$SyncLoadingImplCopyWith<$Res> {
  factory _$$SyncLoadingImplCopyWith(
          _$SyncLoadingImpl value, $Res Function(_$SyncLoadingImpl) then) =
      __$$SyncLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SyncLoadingImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SyncLoadingImpl>
    implements _$$SyncLoadingImplCopyWith<$Res> {
  __$$SyncLoadingImplCopyWithImpl(
      _$SyncLoadingImpl _value, $Res Function(_$SyncLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SyncLoadingImpl with DiagnosticableTreeMixin implements SyncLoading {
  const _$SyncLoadingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.syncLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.syncLoading'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SyncLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return syncLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return syncLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (syncLoading != null) {
      return syncLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return syncLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return syncLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (syncLoading != null) {
      return syncLoading(this);
    }
    return orElse();
  }
}

abstract class SyncLoading implements HomeState {
  const factory SyncLoading() = _$SyncLoadingImpl;
}

/// @nodoc
abstract class _$$SyncSuccessImplCopyWith<$Res> {
  factory _$$SyncSuccessImplCopyWith(
          _$SyncSuccessImpl value, $Res Function(_$SyncSuccessImpl) then) =
      __$$SyncSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Ticket> tickets});
}

/// @nodoc
class __$$SyncSuccessImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SyncSuccessImpl>
    implements _$$SyncSuccessImplCopyWith<$Res> {
  __$$SyncSuccessImplCopyWithImpl(
      _$SyncSuccessImpl _value, $Res Function(_$SyncSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tickets = null,
  }) {
    return _then(_$SyncSuccessImpl(
      null == tickets
          ? _value._tickets
          : tickets // ignore: cast_nullable_to_non_nullable
              as List<Ticket>,
    ));
  }
}

/// @nodoc

class _$SyncSuccessImpl with DiagnosticableTreeMixin implements SyncSuccess {
  const _$SyncSuccessImpl(final List<Ticket> tickets) : _tickets = tickets;

  final List<Ticket> _tickets;
  @override
  List<Ticket> get tickets {
    if (_tickets is EqualUnmodifiableListView) return _tickets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tickets);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.syncSuccess(tickets: $tickets)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.syncSuccess'))
      ..add(DiagnosticsProperty('tickets', tickets));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SyncSuccessImpl &&
            const DeepCollectionEquality().equals(other._tickets, _tickets));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_tickets));

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SyncSuccessImplCopyWith<_$SyncSuccessImpl> get copyWith =>
      __$$SyncSuccessImplCopyWithImpl<_$SyncSuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return syncSuccess(tickets);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return syncSuccess?.call(tickets);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (syncSuccess != null) {
      return syncSuccess(tickets);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return syncSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return syncSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (syncSuccess != null) {
      return syncSuccess(this);
    }
    return orElse();
  }
}

abstract class SyncSuccess implements HomeState {
  const factory SyncSuccess(final List<Ticket> tickets) = _$SyncSuccessImpl;

  List<Ticket> get tickets;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SyncSuccessImplCopyWith<_$SyncSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SyncErrorImplCopyWith<$Res> {
  factory _$$SyncErrorImplCopyWith(
          _$SyncErrorImpl value, $Res Function(_$SyncErrorImpl) then) =
      __$$SyncErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$SyncErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$SyncErrorImpl>
    implements _$$SyncErrorImplCopyWith<$Res> {
  __$$SyncErrorImplCopyWithImpl(
      _$SyncErrorImpl _value, $Res Function(_$SyncErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$SyncErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SyncErrorImpl with DiagnosticableTreeMixin implements SyncError {
  const _$SyncErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.syncError(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.syncError'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SyncErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SyncErrorImplCopyWith<_$SyncErrorImpl> get copyWith =>
      __$$SyncErrorImplCopyWithImpl<_$SyncErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return syncError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return syncError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (syncError != null) {
      return syncError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return syncError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return syncError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (syncError != null) {
      return syncError(this);
    }
    return orElse();
  }
}

abstract class SyncError implements HomeState {
  const factory SyncError(final String message) = _$SyncErrorImpl;

  String get message;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SyncErrorImplCopyWith<_$SyncErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CachingTicketImplCopyWith<$Res> {
  factory _$$CachingTicketImplCopyWith(
          _$CachingTicketImpl value, $Res Function(_$CachingTicketImpl) then) =
      __$$CachingTicketImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CachingTicketImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$CachingTicketImpl>
    implements _$$CachingTicketImplCopyWith<$Res> {
  __$$CachingTicketImplCopyWithImpl(
      _$CachingTicketImpl _value, $Res Function(_$CachingTicketImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CachingTicketImpl
    with DiagnosticableTreeMixin
    implements CachingTicket {
  const _$CachingTicketImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.cachingTicket()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.cachingTicket'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CachingTicketImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return cachingTicket();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return cachingTicket?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (cachingTicket != null) {
      return cachingTicket();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return cachingTicket(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return cachingTicket?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (cachingTicket != null) {
      return cachingTicket(this);
    }
    return orElse();
  }
}

abstract class CachingTicket implements HomeState {
  const factory CachingTicket() = _$CachingTicketImpl;
}

/// @nodoc
abstract class _$$TicketCachedImplCopyWith<$Res> {
  factory _$$TicketCachedImplCopyWith(
          _$TicketCachedImpl value, $Res Function(_$TicketCachedImpl) then) =
      __$$TicketCachedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TicketCachedImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$TicketCachedImpl>
    implements _$$TicketCachedImplCopyWith<$Res> {
  __$$TicketCachedImplCopyWithImpl(
      _$TicketCachedImpl _value, $Res Function(_$TicketCachedImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$TicketCachedImpl with DiagnosticableTreeMixin implements TicketCached {
  const _$TicketCachedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.ticketCached()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HomeState.ticketCached'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TicketCachedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return ticketCached();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return ticketCached?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (ticketCached != null) {
      return ticketCached();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return ticketCached(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return ticketCached?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (ticketCached != null) {
      return ticketCached(this);
    }
    return orElse();
  }
}

abstract class TicketCached implements HomeState {
  const factory TicketCached() = _$TicketCachedImpl;
}

/// @nodoc
abstract class _$$CachingErrorImplCopyWith<$Res> {
  factory _$$CachingErrorImplCopyWith(
          _$CachingErrorImpl value, $Res Function(_$CachingErrorImpl) then) =
      __$$CachingErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CachingErrorImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$CachingErrorImpl>
    implements _$$CachingErrorImplCopyWith<$Res> {
  __$$CachingErrorImplCopyWithImpl(
      _$CachingErrorImpl _value, $Res Function(_$CachingErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CachingErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CachingErrorImpl with DiagnosticableTreeMixin implements CachingError {
  const _$CachingErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HomeState.cachingError(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HomeState.cachingError'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CachingErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CachingErrorImplCopyWith<_$CachingErrorImpl> get copyWith =>
      __$$CachingErrorImplCopyWithImpl<_$CachingErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() signoutLoading,
    required TResult Function() signoutSuccess,
    required TResult Function() signoutError,
    required TResult Function() syncLoading,
    required TResult Function(List<Ticket> tickets) syncSuccess,
    required TResult Function(String message) syncError,
    required TResult Function() cachingTicket,
    required TResult Function() ticketCached,
    required TResult Function(String message) cachingError,
  }) {
    return cachingError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? signoutLoading,
    TResult? Function()? signoutSuccess,
    TResult? Function()? signoutError,
    TResult? Function()? syncLoading,
    TResult? Function(List<Ticket> tickets)? syncSuccess,
    TResult? Function(String message)? syncError,
    TResult? Function()? cachingTicket,
    TResult? Function()? ticketCached,
    TResult? Function(String message)? cachingError,
  }) {
    return cachingError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? signoutLoading,
    TResult Function()? signoutSuccess,
    TResult Function()? signoutError,
    TResult Function()? syncLoading,
    TResult Function(List<Ticket> tickets)? syncSuccess,
    TResult Function(String message)? syncError,
    TResult Function()? cachingTicket,
    TResult Function()? ticketCached,
    TResult Function(String message)? cachingError,
    required TResult orElse(),
  }) {
    if (cachingError != null) {
      return cachingError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SignoutLoading value) signoutLoading,
    required TResult Function(SignoutSuccess value) signoutSuccess,
    required TResult Function(SignoutError value) signoutError,
    required TResult Function(SyncLoading value) syncLoading,
    required TResult Function(SyncSuccess value) syncSuccess,
    required TResult Function(SyncError value) syncError,
    required TResult Function(CachingTicket value) cachingTicket,
    required TResult Function(TicketCached value) ticketCached,
    required TResult Function(CachingError value) cachingError,
  }) {
    return cachingError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SignoutLoading value)? signoutLoading,
    TResult? Function(SignoutSuccess value)? signoutSuccess,
    TResult? Function(SignoutError value)? signoutError,
    TResult? Function(SyncLoading value)? syncLoading,
    TResult? Function(SyncSuccess value)? syncSuccess,
    TResult? Function(SyncError value)? syncError,
    TResult? Function(CachingTicket value)? cachingTicket,
    TResult? Function(TicketCached value)? ticketCached,
    TResult? Function(CachingError value)? cachingError,
  }) {
    return cachingError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SignoutLoading value)? signoutLoading,
    TResult Function(SignoutSuccess value)? signoutSuccess,
    TResult Function(SignoutError value)? signoutError,
    TResult Function(SyncLoading value)? syncLoading,
    TResult Function(SyncSuccess value)? syncSuccess,
    TResult Function(SyncError value)? syncError,
    TResult Function(CachingTicket value)? cachingTicket,
    TResult Function(TicketCached value)? ticketCached,
    TResult Function(CachingError value)? cachingError,
    required TResult orElse(),
  }) {
    if (cachingError != null) {
      return cachingError(this);
    }
    return orElse();
  }
}

abstract class CachingError implements HomeState {
  const factory CachingError(final String message) = _$CachingErrorImpl;

  String get message;

  /// Create a copy of HomeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CachingErrorImplCopyWith<_$CachingErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
